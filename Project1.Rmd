---
title: "Project 1"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=TRUE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)

```

## R Markdown

1.getNodes() is a function to generate nodes in an ad hoc network.
```{r}
getNodes = function(n){
  
  Nodes = matrix(runif(2*n,0,100), ncol = 2)
  colnames(Nodes) <- c("x","y")
  rownames(Nodes) <- 1:n
  
  return(Nodes)
}
```

test for getNodes() with set.seed()
```{r}
seeds = vector(length = 2, mode = "list")
set.seed(12345678)
seeds[[1]] = .Random.seed
a = getNodes(20)
a
seeds[[2]] = .Random.seed
b = getNodes(20)
b
c = list()
for(i in 1:5){
  seeds[[i]] = .Random.seed
  c[[i]] = getNodes(20)
}
c

```

findTranMat() is a function to find the transition matrix based on a distance matrix and a value for R.
```{r}
findTranMat = function(mat, R){
  n = dim(mat)[1]*dim(mat)[2]
  trans.mat = mat
  for(i in 1:n){
    trans.mat[i] = mat[i]<=R
  }
  trans.mat = apply(trans.mat, 1, "/", rowSums(trans.mat))
  return(trans.mat)
}
```

getEigen2() is a function to return the second largest eigenvalue of a matrix.
```{r}
getEigen2 = function(mat){ 
  
  eigenvalues = eigen(mat)$values
  SecondLargest = eigenvalues[order(-eigenvalues)[2]]
  return(SecondLargest) 
  
}
```

findRange() is a function to find the range of Rc to search over based on possible values.
```{r}
findRange = function(mat){
  n = dim(mat)[1]
  IgnoreDiag = mat
  diag(IgnoreDiag) = NA
  
  IgnoreDiag = IgnoreDiag[which(!is.na(IgnoreDiag))]
  
  newMat = matrix(IgnoreDiag,nrow = n, byrow = TRUE)
  
  Min = max(apply(newMat,1,min))
  Max = min(apply(mat,1,max))
  Min.Max = c(Min,Max)
  
  return(Min.Max)
  
}
```

2.(2)findRc() is a function to find the smallest radius, Rc, such that the network is completely connected.
```{r}
findRc = function(nodes, tol = 0.05){
  
  distBNodes1 = as.matrix(dist(nodes))
  
  lower = findRange(distBNodes1)[1]
  upper = findRange(distBNodes1)[2]
  Radius = sum(c(lower,upper))/2
  TranMat = findTranMat(distBNodes1,Radius)
  EigenValue = getEigen2(TranMat)
  
  
  while(abs(upper-lower) > tol){
    
    TranMat = findTranMat(distBNodes1,Radius)
    EigenValue = getEigen2(TranMat)
  
    if(Mod(EigenValue) != EigenValue){
      upper = Radius
    }else{
      lower = Radius
    }
    Radius = sum(c(lower,upper))/2
  }
  return(upper)

}
```

```{r}
x = c(0,0,1,1,10,10,11,11)
y = c(0,1,0,1,0,1,0,1)
yong = matrix(c(x,y),ncol = 2)
findRc(yong,tol = 1)

```


nodeDensity() is a function to take two inputs of numeric vectors of the same length, and returns a numeric vector of values that are proportional to node density at the (x,y) pairs.
```{r}
nodeDensity = function (x, y) {
# x is a numeric vector 
# y is a numeric vector the same length as x
# z is returned. 
# It is a numeric vector that provides the value of the node density function

# Check the inputs for the correct format
if (mode(x) != "numeric" | mode(y) != "numeric") stop("x and y must be numeric")
if (length(x) != length(y)) stop("x and y must be same length")

  a = 3
  b = 1
  band = 15 
  bank = 1
  inBoundary = (0 <= x & x <= 100) & 
             (0 <= y & y <= 100 & y < sqrt(110^2 - x^2))

  river = abs(sqrt(x^2 + y^2) - 60) 
  hiArea = river> bank & river < band & inBoundary

  hiDensity = a * cos(river[hiArea] * pi / (2 * band)) + b 

  z = b * inBoundary
  z[hiArea] = hiDensity
  z[river <= bank] = 0 
  z
}
```

test for nodeDensity
```{r}
nodeDensity(41:60,rep(5,20))
c = getNodes(20)
nodeDensity(c[,1],c[,2])
```

test
```{r}
x = c(1, 2, 3)
y = c(5, 5, 2)

nodes3 = matrix(c(x,y), nrow = 3)

distBNodes = as.matrix(dist(nodes3))

# If R = 3.5 then 
findTranMat(distBNodes, 3.5)
#returns
tranR3.5 = matrix(c(1/2, 1/2, 0, 1/3, 1/3, 1/3, 0, 01/2, 1/2), 
                  byrow = TRUE, nrow = 3)


# and 
getEigen2(tranR3.5)
#returns 0.5 

# If R = 2 then
findTranMat(distBNodes, 2)
#returns
tranR2 = matrix(c(1/2, 1/2, 0, 1/2, 1/2, 0, 0, 0, 1), 
                byrow = TRUE, nrow = 3)

#And 
getEigen2(tranR2)
#returns 1

#Additionally, 
findRange(distBNodes)
#returns approximately
# 3.16227766 3.16227766

#AND
findRc(nodes3, tol = 0.001)
# Returns
# 3.162  

################
#ANother example
nodes5 = matrix(c(1,3,2,1,3,3,3,2,0,0), nrow =5)
distBNodes5 = as.matrix(dist(nodes5))

findTranMat(distBNodes5, 2)
#returns
tranR2 = matrix(c(1/3, 1/3, 1/3, 0, 0, 
                  1/3, 1/3, 1/3, 0, 0,
                  1/3, 1/3, 1/3, 0, 0,
                  0, 0, 0, 1/2, 1/2,
                  0, 0, 0, 1/2, 1/2), 
                byrow = TRUE, nrow = 5)

getEigen2(tranR2)
# returns 1

#Additionally, 
findRange(distBNodes5)
#returns approximately
# 2   2.23608

#Also
tranR2.23 = findTranMat(distBNodes5, 2.23)
getEigen2(tranR2.23)
# returns 1

#AND
findRc(nodes5, tol = 0.0001)
# Returns approximately
#2.23608

# Note that with the tolerances we want to only check
# values that are 0.0001 apart in our Rc range

```

3.Generate 1000 networks and for each find the value for Rc. Examine the distribution of these Rc values. 

test the network with size 20
```{r}
Rc = c()
seeds = vector(length = 2, mode = "list")
set.seed(12345678)
n = 20
networks = vector("list",1000)
for(i in 1:1000){
  seeds[[i]] = .Random.seed
  networks[[i]] = getNodes(n)
}
for(i in 1:1000){
  Rc[i] = findRc(networks[[i]])
}
Rc
```

test for the network with size 50
```{r}
Rc2 = c()
seeds = vector(length = 2, mode = "list")
set.seed(12345678)
m = 50
networks2 = vector("list",1000)
for(i in 1:1000){
  seeds[[i]] = .Random.seed
  networks2[[i]] = getNodes(m)
}
for(i in 1:1000){
  Rc2[i] = findRc(networks2[[i]])
}
Rc2
```

plot for comparing Rc with different size
```{r}
plotRc = function(Rc1, Rc2 = NULL, bw = 2,
           title = 'Compare Rc with different size') 
{
    Rcs = data.frame(
      Rc12 = c(Rc1, Rc2), 
      strat = rep(c(1,2), 
                  times = c(length(Rc1), length(Rc2)))
      )
    require(ggplot2)
    ggplot(data = Rcs) + 
      geom_density(aes(x = Rc12, y = ..density.., 
                       color = factor(strat)), 
                   bw = bw) +
      scale_x_continuous("Smallest Radius(Rc) for 1000 Networks") +
      ggtitle(title) +
      scale_colour_manual(values = c(1,2), name = 'Density', labels = c('Rc1','Rc2'))
}
```

comparison Rc and RcTwo with different size
```{r}

summary(Rc)
summary(Rc2)
plotRc(Rc, Rc2, bw = 1,
          title = "Compare Rc for 1000 networks with different size\nRc1 with size of 20 vs Rc2 with size of 50")
```




```{r histogram of Rc for one thousands networks with size of twenty}
summary(Rc)
Histogram = hist(Rc, breaks = 20, col = "pink", xlab = "Rc of 1000 networks(Symmetric)", main = "Histogram of Rc of 1000 Networks")
print("The the distribution of Rc of 1000 Networks is 'Symmetric'.")
Histogram

```


find the 4 Rc values that coincide with (or are close to) the minimum, maximum, median, and mean Rc value
```{r}
Min = min(Rc)
Median = median(Rc)
Mean = mean(Rc)
Max = max(Rc)

Min
Median
Mean
Max

i = which(abs(Rc-Min)<=0.005)
j = which(abs(Rc-Median)<=0.005)
k = which(abs(Rc-Mean)<=0.005)
l = which(abs(Rc-Max)<=0.005)
if(length(i)>1 | length(j)>1 | length(k)>1 | length(l)>1){
  i = i[1]
  j = j[1]
  k = k[1]
  l = l[1]
}
CloseMin = Rc[i]
CloseMedian = Rc[j]
CloseMean = Rc[k]
CloseMax = Rc[l]

c(i, CloseMin)
c(j, CloseMedian)
c(k, CloseMean)
c(l, CloseMax)
```

test for Min Median Mean Max Rc with size of twenty of the network
```{r}
mindf = data.frame(networks[i])
comb = combn(nrow(mindf), 2)
connected = comb[,which(as.numeric(dist(networks[[i]]))<=Rc[i])]
connections = data.frame(
  from = mindf[connected[1, ], 1:2],
  to = mindf[connected[2, ], 1:2]
)
names(connections) = c("x1", "y1", "x2", "y2")

plot1 = ggplot(mindf,aes(x=mindf$x,y=mindf$y)) +
  geom_point(col = "red", size = 3) +
  geom_segment(data = connections, aes(x=x1, y=y1, xend=x2, yend=y2), col="blue") +
  labs(x = "X-coordinate", y = "Y-coordinate", title = "Plots of the Smallest Rc")
plot1


mediandf = data.frame(networks[j])
comb2 = combn(nrow(mediandf), 2)
connected2 = comb2[,which(as.numeric(dist(networks[[j]]))<=Rc[j])]
connections2 = data.frame(
  from = mediandf[connected2[1, ], 1:2],
  to = mediandf[connected2[2, ], 1:2]
)
names(connections2) = c("x1", "y1", "x2", "y2")

plot2 = ggplot(mediandf,aes(x=mediandf$x,y=mediandf$y)) +
  geom_point(col = "black", size = 3) +
  geom_segment(data = connections2, aes(x=x1, y=y1, xend=x2, yend=y2), col="skyblue") +
  labs(x = "X-coordinate", y = "Y-coordinate", title = "Plots of Median of Rc")
plot2


meandf = data.frame(networks[k])
comb3 = combn(nrow(meandf), 2)
connected3 = comb[,which(as.numeric(dist(networks[[k]]))<=Rc[k])]
connections3 = data.frame(
  from = meandf[connected3[1, ], 1:2],
  to = meandf[connected3[2, ], 1:2]
)
names(connections3) = c("x1", "y1", "x2", "y2")

plot3 = ggplot(meandf,aes(x=meandf$x,y=meandf$y)) +
  geom_point(col = "green", size = 3) +
  geom_segment(data = connections3, aes(x=x1, y=y1, xend=x2, yend=y2), col="pink") +
  labs(x = "X-coordinate", y = "Y-coordinate", title = "Plots of Mean of Rc")
plot3


maxdf = data.frame(networks[l])
comb4 = combn(nrow(maxdf), 2)
connected4 = comb[,which(as.numeric(dist(networks[[l]]))<=Rc[l])]
connections4 = data.frame(
  from = maxdf[connected4[1, ], 1:2],
  to = maxdf[connected4[2, ], 1:2]
)
names(connections4) = c("x1", "y1", "x2", "y2")

plot4 = ggplot(maxdf,aes(x=maxdf$x,y=maxdf$y)) +
  geom_point(col = "orange", size = 3) +
  geom_segment(data = connections4, aes(x=x1, y=y1, xend=x2, yend=y2), col="brown") +
  labs(x = "X-coordinate", y = "Y-coordinate", title = "Plots of the Largest Rc")
plot4


```

